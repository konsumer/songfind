<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>songfind</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" />
    <style>
      body { display: grid; place-items: center; height: 100vh; width: 100vw; }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <button id="btn">Find Song</button>
      <p id="status"></p>
      <pre id="result"></pre>
    </div>

    <script type="module">
      import { fingerprint } from "./fingerprint.js";

      const CHUNK_MS = 5000;
      const MAX_CHUNKS = 3;
      const btn = document.getElementById("btn");
      const status = document.getElementById("status");
      const result = document.getElementById("result");
      let active = false;

      btn.onclick = async () => {
        if (active) return;
        active = true;
        btn.disabled = true;
        result.textContent = "";
        try {
          await run();
        } catch (err) {
          status.textContent = `Error: ${err.message}`;
        }
        btn.disabled = false;
        active = false;
      };

      function run() {
        return new Promise(async (resolve, reject) => {
          status.textContent = "Requesting mic...";
          let stream;
          try {
            stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          } catch (err) {
            return reject(err);
          }

          const recorder = new MediaRecorder(stream);
          const chunks = [];
          let busy = false;

          recorder.onstop = () => { stream.getTracks().forEach((t) => t.stop()); resolve(); };
          recorder.onerror = (e) => { stream.getTracks().forEach((t) => t.stop()); reject(e.error); };

          recorder.ondataavailable = async (e) => {
            if (e.data.size === 0) return;
            chunks.push(e.data);
            if (busy) return;
            busy = true;

            status.textContent = `Identifying... (${chunks.length * (CHUNK_MS / 1000)}s)`;

            try {
              const buf = await new Blob(chunks, { type: recorder.mimeType }).arrayBuffer();
              const ctx = new AudioContext();
              let audioBuffer;
              try {
                audioBuffer = await ctx.decodeAudioData(buf.slice(0));
              } finally {
                ctx.close();
              }

              const codes = await fingerprint(audioBuffer);
              if (!codes.length) { busy = false; return; }

              const res = await fetch("/identify", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ codes }),
              });
              const data = await res.json();

              if (data.found) {
                recorder.stop();
                status.textContent = `Found! (${data.score} codes matched)`;
                result.textContent = [data.title, data.artist, data.album].filter(Boolean).join("\n");
                return;
              }

              if (chunks.length >= MAX_CHUNKS) {
                recorder.stop();
                status.textContent = "Song not found â€” try again.";
                return;
              }

              busy = false;
              status.textContent = "Still listening...";
            } catch (err) {
              recorder.stop();
              reject(err);
            }
          };

          status.textContent = "Listening...";
          recorder.start(CHUNK_MS);
        });
      }
    </script>
  </body>
</html>
